Designing Robotspeak required deliberate trade-offs to balance expressiveness, flexibility, and simplicity with the ease of implementing the interpreter and the restrictions imposed by the assignment (limited vocabulary size, etc). Every token in the language was carefully chosen to maximize utility while keeping the language approachable and the interpreter manageable.


The inclusion of LOAD and END reflects this principle. LOAD provides a clear, unambiguous entry point for programs, while END not only marks program termination but is also able to be reused to close control structures. This reuse keeps the vocabulary smaller and gives the parser a simple way to detect block boundaries and the end of control statements, which were definitely the hardest structures to code in the language. The decision to rely on line numbers to distinguish between the program-closing END and those belonging to IF and WHILE statements was done to facilitate the reused nature of the END token.

Nested IF and WHILE statements were able to be implemented using the current CONTROL…END system. For increased flexibility, OTHERWISE was added as an extension of IF statements, but no form of ELIF was implemented. Workarounds using nested IF or OTHERWISE blocks were sufficient for the problem space, and excluding ELIF avoided additional parsing complexity and vocabulary growth.

The language restricts its data types to TRUE and FALSE. Arithmetic was deliberately excluded as it was unnecessary for writing code and would have introduced complexity in both language design and interpreter coding. This is the same with parentheses, which were removed midway, as operator precedence rules with AND and OR were sufficient to create solution algorithms without further complicating the already complex boolean expression function.

Robotspeak also does not permit the use of functions. The benefits of functions like modularity and reuse would not have been useful for solving maze navigation that only needs simple scripts. This would’ve also added much more complexity to coding the interpreter. Everything was able to work around this and coding solutions following the imperative paradigm were able to be created.

To conclude, Robotspeak demonstrates how constraints shaped both vocabulary and semantics. By limiting features, the language remained consistent, easy to parse and fit the constraints imposed by the assignment. The trade-offs ensured that while Robotspeak is by no means a general-purpose language, it succeeds as a structured, imperative mini-language that is sufficiently adequate to control the runner through each of the three maze types.
